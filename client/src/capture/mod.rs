use std::{io::{BufWriter, Write}, sync::Arc, time::Duration};
use shared::{encrypted_write_from_key, DataPacket, StatusType};
use tokio::{net::tcp::OwnedWriteHalf, sync::{watch, Mutex}};
use xcap::Monitor;

pub struct Screenshot {
    pub monitors: Vec<Monitor>,
    pub writer: Arc<Mutex<OwnedWriteHalf>>,
    pub key: [u8; 32],
    pub notifier: watch::Sender<StatusType>,
}


impl Screenshot {


    pub fn new(writer: Arc<Mutex<OwnedWriteHalf>>, key: [u8 ;32], notifier: watch::Sender<StatusType>) -> xcap::XCapResult<Self> {
        let monitors = Monitor::all()?;
        Ok(Self {
            writer,
            key,
            notifier,
            monitors,
        })
    }
    
    //send a screenshot of each monitor connected
    pub async fn process_screenshots(&self) -> std::io::Result<()> {
        loop {
            for monitor in &self.monitors {
                if let Ok(image) = screenshot(monitor) {
                    let data = DataPacket {
                        module_type: shared::ModuleType::Capture,
                        data: image,
                    };
                    encrypted_write_from_key(self.writer.clone(), &self.key, data).await?;
                    println!("sent image");
                }
            }
            tokio::time::sleep(Duration::from_secs(600)).await;
        
        }
    }

    
}
// perform the sc using windows API wrapper
fn screenshot(monitor: &Monitor) -> xcap::XCapResult<Vec<u8>>{
    let v = Vec::new();
    let image = monitor.capture_image()?;
    let mut ret = BufWriter::new(std::io::Cursor::new(v));
    image.write_to(&mut ret, image::ImageFormat::Png).unwrap();
    ret.flush().unwrap();

    if let Ok(cursor) = ret.into_inner() {
        return Ok(cursor.into_inner())
    }
    Err(xcap::XCapError::new("unable to unwrap bufwriter"))
}